package declarative

import (
	"errors"
	"github.com/go-logr/logr"
	"github.com/go-logr/zerologr"
	"github.com/kyma-project/module-manager/operator/pkg/types"
	"github.com/rs/zerolog"
	"github.com/stretchr/testify/assert"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"os"
	"testing"
)

func TestGet(t *testing.T) {
	zl := zerolog.New(os.Stderr)
	zl = zl.With().Caller().Timestamp().Logger()
	var logger logr.Logger = zerologr.New(&zl)

	type test struct {
		testName                 string
		name                     string
		namespace                string
		object                   types.BaseCustomObject
		expectedInstallationSpec types.InstallationSpec
		expectedErr              error
	}

	tests := []test{
		{
			testName:  "Resolve object with valid values",
			name:      "testCR",
			namespace: "default",
			object: &TestCRD{
				Spec: types.InstallationSpec{
					ChartPath:   "path/to/chart",
					ReleaseName: "test-release",
					ChartFlags:  types.ChartFlags{},
				},
			},
			expectedInstallationSpec: types.InstallationSpec{ChartPath: "path/to/chart", ReleaseName: "test-release", ChartFlags: types.ChartFlags{}},
			expectedErr:              nil,
		},
		{
			testName:  "`chartPath` not given",
			name:      "testCR",
			namespace: "default",
			object: &TestCRD{
				Spec: types.InstallationSpec{
					ChartFlags: types.ChartFlags{},
				},
			},
			expectedInstallationSpec: types.InstallationSpec{},
			expectedErr: &ResolveError{
				objectName: "default/testCR",
				Err:        errors.New(errMsgMandatory),
			},
		},
		{
			testName:  "Resolve object with minimal valid input",
			name:      "testCR",
			namespace: "default",
			object: &TestCRD{
				Spec: types.InstallationSpec{
					ChartPath: "path/to/chart",
				},
			},
			expectedInstallationSpec: types.InstallationSpec{ChartPath: "path/to/chart", ReleaseName: ""},
			expectedErr:              nil,
		},
		{
			name:                     "",
			object:                   nil,
			expectedInstallationSpec: types.InstallationSpec{},
			expectedErr:              nil,
		},
	}

	for _, tc := range tests {
		resolver := DefaultManifestResolver{}
		t.Run(tc.testName, func(t *testing.T) {
			tc.object.SetName(tc.name)
			tc.object.SetNamespace(tc.namespace)
			installationSpec, err := resolver.Get(tc.object, logger)
			assert.Equal(t, tc.expectedInstallationSpec, installationSpec)
			assert.Equal(t, tc.expectedErr, err)
		})
	}
}

// TestCRD implements the BaseCustomObject and can be used for easy testing
type TestCRD struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   types.InstallationSpec `json:"spec,omitempty"`
	Status types.Status           `json:"status,omitempty"`
}

func (s *TestCRD) GetStatus() types.Status {
	//return s.Status
	return types.Status{}
}

func (s *TestCRD) SetStatus(status types.Status) {
	//s.Status = status
}

func (s *TestCRD) ComponentName() string {
	return "test-component-name"
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TestCRD) DeepCopyInto(out *TestCRD) {
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TestCRD.
func (in *TestCRD) DeepCopy() *TestCRD {
	return nil
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *TestCRD) DeepCopyObject() runtime.Object {
	return nil
}
